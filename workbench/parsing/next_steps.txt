
Based on the current state of your program, the next step should focus on integrating the parsing and execution components to create a seamless workflow. Here's a step-by-step plan:

1. Connect Parsing to Execution
Goal: 
	X Use the tokens generated by the parsing phase to drive the execution phase.
Steps:
	X Ensure the tokenize_input function in tokens.c produces a valid linked list of tokens (t_list 
	of t_token).
	X Pass the token list to the execution function, such as ft_execute.
	Handle built-in commands (e.g., cd, echo) directly in the parent process using choose_b_in.
		X echo
		cd
		exit
		export
		env
		pwd
		unset
	For external commands, fork a child process and execute them using execute2.
	
2. Implement Token Expansion
Goal: 	Expand tokens for environment variables, $?, and ~ before execution.
Steps:
	Use the expander function in minishell.h to process tokens.
	Implement environment variable expansion using expand_env_var.
	Handle $? expansion to replace it with the last exit code (shell->exit_code).
	Expand ~ to the value of the HOME environment variable.
	
3. Handle Redirections and Pipes
Goal: 	Set up redirections and pipes based on the parsed tokens.
Steps:
	Use helper functions like file_handling and pipe_handling to identify redirection and pipe 
	tokens.
	For redirections (<, >, >>), open the appropriate files and use dup2 to redirect stdin or 
	stdout.
	For pipes (|), create a pipe using pipe() and connect the output of one command to the input of 
	the next.
	
4. Error Handling
Goal: 	Ensure robust error handling for invalid commands, syntax errors, and execution failures.
Steps:
	Validate the token list for syntax errors (e.g., unmatched quotes, invalid operators) using 
	validate_input.
	Handle command-not-found errors in execute2 by checking the return value of execve.
	Print meaningful error messages using print_error.
	
5. Update Shell State
Goal: 	Keep the shell state (t_shell) updated after each command.
Steps:
	Update the exit_code in t_shell after each command execution.
	For cd, update PWD and OLDPWD using cd_env.
	For export and unset, modify the environment variable list using update_env.
	
6. Testing and Debugging
Goal: 	Ensure all components work together as expected.
Steps:
	Test simple commands (e.g., ls, pwd) and built-ins (e.g., cd, echo).
	Test commands with pipes (e.g., ls | grep text) and redirections (e.g., echo hello > file.txt).
	Test edge cases, such as invalid commands, syntax errors, and permission issues.
	
7. Memory Management
Goal: 	Prevent memory leaks and ensure proper cleanup.
Steps:
	Free all allocated memory for tokens using free_tokens.
	Free the shell state (t_shell) and environment variables using free_env.
	
Immediate Next Step
	Start by integrating the parsing and execution phases:

Modify the main function in main.c to pass the token list from tokenize_input to ft_execute.
Ensure built-ins and external commands are handled correctly.
This integration will allow you to test the full workflow and identify any gaps in functionality.
